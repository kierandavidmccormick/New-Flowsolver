package src;

import java.util.ArrayList;
import java.util.List;

/**
 * The main home of the algorithm itself used to solve Numberlink puzzles.
 * It uses Iterative Deepening Search (IDS) to minimize memory usage while still keeping the search tree as shallow as possible.
 * Additionally, there's a mechanism of "proof by counterexample" to find moves that inevitably lead to a dead end, allowing the solver to skip them entirely.
 * 
 * Potential improvements:
 * - Implement more sophisticated heuristics for choosing which locations to evaluate first, more sophisticated than just the shallowest depth
 */

public class Solver {
    // Count of boards created during the solving process, for performance monitoring and debugging
    public static int boardsCreated = 0;

    /**
     * Solve the given board, returning a list of boards representing the solution path.
     * @param board The board to solve
     * @param moveHistory List in which to store the history of moves made to reach each board in the solution path
     * @return A list of boards representing the solution path
     */
    public static ArrayList<Board> solveBoard(Board board, ArrayList<Move[]> moveHistory) {
        boardsCreated = 0;
        ArrayList<Board> solution = new ArrayList<>();
        solution.add(board);

        moveHistory.add(new Move[]{}); // Add an empty array since the first board isn't generated by a move

        while (true) {
            // Iterative Deepening Search (IDS) with a depth limit of 4
            // The depth limit is only there to stop the algorithm from running forever on unsolvable boards; it can be increased if necessary

            Move[] forcedMoves = null;
            int depthLimitAt = 0;
            for (int depthLimit = 0; depthLimit <= 4; depthLimit++) {

                if (depthLimit >= 0) {
                    System.out.println("Searching for forced moves at depth " + depthLimit + " - Created " + boardsCreated + " boards so far");
                }

                // Try to find a forced move at the current depth limit
                forcedMoves = findForcedMoves(solution.get(solution.size() - 1), depthLimit);
                if (forcedMoves != null || board.isSolved()) {
                    depthLimitAt = depthLimit;
                    break;
                }
            }
            if (forcedMoves == null) {
                // No forced move found; return the current solution
                return solution;
            }

            // Apply the forced move(s) that were just found to generate the next board state
            try {
                Board newBoard = new Board(solution.get(solution.size() - 1));
                boardsCreated++;
                for (Move forcedMove : forcedMoves) {
                    newBoard.applyMove(forcedMove);
                }
                moveHistory.add(forcedMoves);
                solution.add(newBoard);

                if (depthLimitAt > 0) {
                    System.out.println("Found forced move: at d=" + depthLimitAt + " " + forcedMoves[0] + (forcedMoves.length > 1 ? " and " + forcedMoves[1] : "") + " - Created " + boardsCreated + " boards so far");
                    System.out.println(newBoard.simpleReadout());
                } if (depthLimitAt == 0) {
                    System.out.println("Found forced move: at d=" + depthLimitAt + " " + forcedMoves[0] + (forcedMoves.length > 1 ? " and " + forcedMoves[1] : "") + " - Created " + boardsCreated + " boards so far");
                    // System.out.println(newBoard.simpleReadout());
                }
                
                if (newBoard.isSolved()) {
                    System.out.println("Board is solved! - Created " + boardsCreated + " boards in total");
                    return solution;
                }
            } catch (InvalidMoveException e) {
                // This shouldn't happen, but if it does, just return the current solution
                System.err.println("Invalid move: " + e.getMessage());
                return solution;
            }
        }
    }

    /**
     * Find a set of forced moves for the given board at the specified depth limit.
     * @param board The board to analyze
     * @param depthLimit The maximum depth to search for forced moves
     * @return An array of forced moves, or null if none are found
     */
    public static Move[] findForcedMoves(Board board, int depthLimit) {

        ArrayList<Location> openLocations = board.getOpenLocations();

        // Check locations with fewer connection possibilities and more open connections first
        // From lowest to highest on countMoveCombinations
        sortLocationsByConnections(openLocations, board);

        // Check all open locations for forced moves
        for (Location loc : openLocations) {
            ArrayList<Move[]> combos = loc.getValidMoveCombinations(board);
            ArrayList<Move[]> validCombos = new ArrayList<>(2); // We only care if there's 0, 1, or more than 1 valid combination, so we can limit the size of this list to 2
            
            // Filter each move combination to see if it leads to an invalid board or dead-end; keep only those that don't
            for (Move[] combo : combos) {
                Board testBoard = new Board(board);
                boardsCreated++;
                try {
                    testBoard.applyMoves(combo);
                } catch (InvalidMoveException e) {
                    // Leads to an invalid board; eliminate this one
                    continue;
                }

                if (depthLimit > 0 && isDeadly(testBoard, depthLimit, combo[0].getStart())) {
                    // Leads to a dead-end; eliminate this one
                    continue;
                }

                validCombos.add(combo);

                if (validCombos.size() > 1) {
                    continue;      // If there's more than one valid combination, we already know there's no forced move here, so skip the rest of the checks
                }
            }

            if (validCombos.size() == 0) {
                // If there are no valid combinations left, we shouldn't be here
                System.err.println("Location " + loc.getCoordinate() + " has no valid move combinations");
                return null;
            } else if (validCombos.size() == 1) {
                // If there's only one combination left, return it
                return validCombos.get(0);
            }
            // Otherwise, if there's more than one valid combination, we can't make a forced move here, so we've found nothing

        }
        return null;
    }

    /**
     * Check if the given board is "deadly", meaning that it inevitably leads to a dead end where at least one location has no valid moves left.
     * Note that a deadly location will still have valid moves available, but searching down any of those paths will eventually lead to a dead end before the puzzle is solved.
     * This is done using a recursive, depth-limited search.
     * @param board The board to check
     * @param depthLimit The depth limit for the search
     * @param target The coordinate to prioritize when sorting locations; if null, locations are sorted by number of connections instead
     * @return True if the board is deadly, false otherwise
     */
    public static boolean isDeadly(Board board, int depthLimit, Coordinate target) {
        if (depthLimit == 0) {
            // Too deep; give up
            return false;
        }

        // Get all open locations on the board and sort to put the most promising ones first
        ArrayList<Location> openLocations = board.getOpenLocations();
        if (target == null) {
            // Sort by the number of connections available to find a promising location, wherever it is
            sortLocationsByConnections(openLocations, board);
        } else {
            // Sort by the distance to the target to quickly evaluate a move at a particular location
            sortLocationsByDistance(openLocations, target);
        }

        // Check all open locations for forced moves
        for (Location loc : openLocations) {
            ArrayList<Move[]> moveCombos = loc.getValidMoveCombinations(board);
            if (moveCombos.isEmpty()) {
                return true; // No valid move combinations from this location, so this move is deadly
            }

            // Check to see if there is at least one valid, non-deadly move
            boolean hasValidCombo = false;
            for (Move[] combo : moveCombos) {
                Board newBoard = new Board(board);
                try {
                    newBoard.applyMoves(combo);
                } catch (InvalidMoveException e) {
                    // Invalid move; skip this one
                    continue;
                }

                // Deepen the search to see if this move leads to a dead end
                if (depthLimit == 0 || !isDeadly(newBoard, depthLimit - 1, combo[0].getStart())) {      // Since all moves in the combo start from the same location, we can just pick the first one
                    hasValidCombo = true;
                    continue; // Don't bother checking the rest of the combos, all we need is one that's valid
                }
            }

            if (!hasValidCombo) {
                return true; // There's at least one location with no valid move combinations, which means this whole branch of the search tree is invalid
            }
        }
        return false; // All open locations have at least one valid move combination; the search tree can continue from here
    }

    /**
     * Sort the given list of locations by the number of connections available, then by their coordinates.
     * It's important for performance to pick good locations first - we choose the ones with the most restricted connections first
     * This is a total ordering so the search is deterministic
     * @param locations The list of locations to sort
     * @param board The board containing the locations
     */
    public static void sortLocationsByConnections(List<Location> locations, Board board) {
        locations.sort((a, b) -> {
            // Sort by the number of move combinations available at each location
            int aCount = a.countMoveCombinations(board);
            int bCount = b.countMoveCombinations(board);

            // If the counts are not equal, sort by that
            if (aCount != bCount) {
                return Integer.compare(aCount, bCount);
            }

            // If the counts are equal, sort by the xcoordinate, then by the ycoordinate
            if (a.getCoordinate().getRow() != b.getCoordinate().getRow()) {
                return Integer.compare(a.getCoordinate().getRow(), b.getCoordinate().getRow());
            } else {
                return Integer.compare(a.getCoordinate().getCol(), b.getCoordinate().getCol());
            }
        });
    }

    /**
     * Sort the given list of locations by their Manhattan distance to the target coordinate, then by their coordinates.
     * This is a total ordering so the search is deterministic
     * @param locations The list of locations to sort
     * @param target The target coordinate to sort by distance to
     */
    public static void sortLocationsByDistance(List<Location> locations, Coordinate target) {
        locations.sort((a, b) -> {
            // Sort by the distance to the target coordinate
            int aDistance = a.getCoordinate().manhattanDistance(target);
            int bDistance = b.getCoordinate().manhattanDistance(target);

            // If the distances are not equal, sort by that
            if (aDistance != bDistance) {
                return Integer.compare(aDistance, bDistance);
            }

            // If the distances are equal, sort by the xcoordinate, then by the ycoordinate
            if (a.getCoordinate().getRow() != b.getCoordinate().getRow()) {
                return Integer.compare(a.getCoordinate().getRow(), b.getCoordinate().getRow());
            } else {
                return Integer.compare(a.getCoordinate().getCol(), b.getCoordinate().getCol());
            }
        });
    }
}